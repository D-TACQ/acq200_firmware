/*
 * rbtfilter.cpp ... converts rbt file to assembler module
 *
 * 1: scan header section from rbt.
 * 2: establish lca mode
 * 3: build lca prom model
 * 4: build output file
 *
 * LCA code is held as:

		NBYTES { 16 bit } - #bytes of lca code rounder up to nearest byte
		CODEOFF { 16 }		offset to start of code
		header              ascii text header from RBT file
		the code            bit stream in binary form
 * USAGE:
 *		rbtfilter <filename>
 *
 * rbtfilter gleans the mode from the file header, <filename> is ignored.
 *
 * references: 
 *	1		XILINX manual p4-202
 */

#include <stdio.h>
#include <string.h>

#include <assert.h>

/*
 * model the bitstream file as
 */

typedef unsigned int unsigned32;
typedef unsigned char byte;


const int MAXBITS = 0x40000;

enum {
	FILLBYTE = 0xff,
	PREAMBLE = 0xf2
};


typedef union {
	byte Raw[MAXBITS];
	struct {
		byte FillByte;
		byte Preamble;
		byte Count[3];		// COUNT(23:0)
	}
		Cooked;
}
	Bitstream;
	

const int MAXLINE = 1024;		// max line length in rbt

void swallow( char cc )
{
	putchar( cc );
}


class Filter {
	bool	m_BOL;							// true if at beginning of line
	enum { MAXHEADER = 1024 };
	enum { STARTMASK = 0x01 };					// top bit first
	enum { IN_HEADER, IN_BITS } m_state;
	char *m_Header;
	char *m_HeaderPtr;
	Bitstream* m_Bitstream;
	byte* m_RawPtr;
	unsigned char m_BitMask;
	char m_Section[40];

	char m_fname_out[80];

	FILE* fp_out;

	int	 NBits()		 { return m_RawPtr - &m_Bitstream->Raw[0]; }
	bool IsB0( char cc ) { return cc == '0'; }
	bool IsB1( char cc ) { return cc == '1'; }
	bool IsBX( char cc ) { return IsB0(cc) || IsB1(cc); }

	void OpenFile()
	{
		fp_out = fopen( m_fname_out, "w" );

		assert( fp_out );

		fprintf( fp_out, "; file %s generated by rbtfilter from XLINX source\n", m_fname_out );
	}
	void OutputPreamble()
	{

		fprintf( fp_out, "\n\n AREA %s,DATA,READONLY\n\n", m_Section );
		fprintf( fp_out, "start\n" );
		fprintf( fp_out, " DCD %d%50s\n", NBits(), ";#bytes in bitstream" );
		fprintf( fp_out, " DCD bitstart-start%50s\n", "; byte offset of bits start" );
	}
	void OutputHeader()
	{
		char* pc = m_Header;
		bool newline = true;

		for ( ; *pc; ++pc )
		{
			if ( newline )
			{
				fprintf( fp_out, " DCB \"" );
			}
			if ( *pc == '\n' )
			{
				fprintf( fp_out, "\",0\n" );
				newline = true;
			}
			else
			{
				fputc( *pc, fp_out );
				newline = false;
			}
		}
		
	}
	void OutputBitstream()
	{
		fprintf( fp_out, "\nbitstart\n" );
		byte* pb = &m_Bitstream->Raw[0];
		int iline = 0;

		for ( ; pb != m_RawPtr+1; ++pb, iline = ++iline&0xf )
		{
			if ( iline == 0 )
			{
				fprintf( fp_out, "\n DCB 0x%02x", *pb );
			}
			else
			{
				fprintf( fp_out, ",0x%02x", *pb );
			}
		}

		fprintf( fp_out, "\n" );
 	}
	void OutputPostamble()
	{
		fprintf( fp_out, " END\n" );
		fprintf( fp_out, ";End of Run\n" );
	}
	void CloseFile()
	{
		fclose( fp_out );
	}

public:
	Filter( const char* fname )
	{
		m_BOL = true;
		m_state = IN_HEADER;
		m_Header = new char[MAXHEADER];
		memset( m_Header, 0, MAXHEADER );
		m_HeaderPtr = m_Header;

		m_Bitstream = new Bitstream;
		memset( m_Bitstream, 0, sizeof(Bitstream) );
		m_RawPtr = &m_Bitstream->Raw[0];

		m_BitMask = STARTMASK;

		strcpy( m_fname_out, fname );
		strcat( m_fname_out, ".s" );

		memset( m_Section, 0, sizeof( m_Section ) );

		const char* psn = fname;

		// strip any path separators

		for( char* psep; psep = strpbrk( psn, "/\\" ); psn = psep + 1 )
			;
			
		int ncopy = strchr( psn, '.' )? strchr( psn, '.' )-psn: strlen(psn);

		strcpy( m_Section, "lca_" );
		strncat( m_Section, psn, ncopy );
	}

	void Swallow( char cc )
	{
		if ( m_state == IN_HEADER )
		{
			if ( m_BOL && IsBX( cc ) )			// start of bitstream
			{
				m_state = IN_BITS;					// just change state
				Swallow( cc );						// &swallow again
			}
			else
			{
				*m_HeaderPtr++ = cc;
			}
		}
		else							
		{
			if ( IsBX( cc ) )
			{
				*m_RawPtr |= IsB1( cc )? m_BitMask: 0;		// set the bit if needed
				
				if ( (m_BitMask <<= 1) == 0 )				// byte full action
				{
					m_RawPtr++;
					m_BitMask = STARTMASK;
				}
			}
		}
		m_BOL = cc == '\n';
	}

	void Spew()
	{
		OpenFile();
		OutputPreamble();
		OutputHeader();
		OutputBitstream();
		OutputPostamble();
		CloseFile();
	}
};
int main( int argc, char* argv[] )
{
	if ( argc == 2 )
	{
		char* infile = argv[1];

		FILE* fp = fopen( infile, "r" );
		int cc;

		if ( fp == 0 )
		{
			fprintf( stderr, "ERROR: failed to open input file %s\n", infile );
			return -1;
		}


		Filter* the_filter = new Filter( infile );

		while ((cc = fgetc( fp )) != EOF )
		{
			the_filter->Swallow( cc );
		}

		fclose( fp );

		the_filter->Spew();
		return 0;
	}
	else
	{
		fprintf( stderr, "USAGE: rbtfilter <rbtfile>\n" );
		return -1;
	}
}

